.. _direnv-stdlib:

The standard library
====================

The stdlib is a set of bash utility functions that are loaded in the context of an .envrc and make day to day tasks easier.

The stdlib is compiled inside the direnv executable to keep the distribution of direnv inside a single binary (except the man pages).

Extending or replacing functions of the stdlib is also possible by placing bash function in a "~/.direnvrc" file in your home directory.

.. tip:: run ``direnv stdlib | less`` to read the content of the stdlib from the shell.

Commands
--------

.. _stdlib_log_status:
``log_status <text>``
^^^^^^^^^^^^^^^^^^^^^

Logs a status message. Acts like echo, but wraps output in the standard direnv log format (controlled by $DIRENV_LOG_FORMAT), and directs it to stderr rather than stdout.

Example::

    log_status "Loading ..."


.. _stdlib_has:
``has <command>``
^^^^^^^^^^^^^^^^^

Returns 0 if the <command> is available. Returns 1 otherwise. The command can be a binary in the PATH or a shell function.

Example::

    if has curl; then
      echo "Yes we do"
    fi


.. _stdlib_expand_path:
``expand_path <rel_path> [<relative_to>]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Outputs the absolute path of <rel_path> relaitve to <relative_to> or the current directory.

.. note:: implented by the ``direnv expand_path`` internal command.

Example::

    cd /usr/local/games
    expand_path ../foo
    # output: /usr/local/foo


.. _stdlib_dotenv:
``dotenv [<dotenv>]``
^^^^^^^^^^^^^^^^^^^^^

Loads a ".env" file into the current environment. The format of this file is
 defined by the `dotenv <https://github.com/bkeepers/dotenv>` project.

.. note:: implented by the ``direnv dotenv`` internal command.


.. _stdlib_user_rel_path:
``user_rel_path <abs_path>``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Transforms an absolute path <abs_path> into a user-relative path if possible. Useful to shorten printed outputs of a path.

Example::

    echo $HOME
    # output: /home/user
    user_rel_path /home/user/my/project
    # output: ~/my/project
    user_rel_path /usr/local/lib
    # output: /usr/local/lib


.. _stdlib_find_up:
``find_up <filename>``
^^^^^^^^^^^^^^^^^^^^^^

Outputs the path of <filename> when searched from the current directory up to /. Returns 1 if the file has not been found.

Example::

    cd /usr/local/my
    mkdir -p project/foo
    touch bar
    cd project/foo
    find_up bar
    # output: /usr/local/my/bar


.. _stdlib_source_env:
``source_env <file_or_dir_path>``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Loads another ".envrc" either by specifying its path or filename.


.. _stdlib_source_up:
``source_up [<filename>]``
^^^^^^^^^^^^^^^^^^^^^^^^^^

Like :ref:`stdlib_source_env` except that the file is looked up using :ref:`stdlib_find_up`. <filename> is ".envrc" by default.


.. _stdlib_direnv_load:
``direnv_load <command-generating-dump-output>``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Applies the environment generated by running <argv> as a command. This is useful for adopting the environment of a child process - cause that process to run "direnv dump" and then wrap the results with direnv_load.

Example::

    direnv_load opam-env exec -- direnv dump


.. _stdlib_PATH_add:
``PATH_add <path>``
^^^^^^^^^^^^^^^^^^^

Prepends the expanded <path> to the PATH environment variable. It prevents a common mistake where PATH is replaced by only the new <path>.

Example::

    pwd
    # output: /home/user/my/project
    PATH_add bin
    echo $PATH
    # output: /home/user/my/project/bin:/usr/bin:/bin


.. _stdlib_path_add_var:
``path_add <varname> <path>``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Works like PATH_add except that it's for an arbitrary <varname>.

Example::

    export LIBRARY_PATH=/lib
    cd /usr
    path_add LIBRARY_PATH lib
    echo $LIBRARY_PATH
    # output: /usr/lib:/lib


.. _stdlib_load_prefix:
``load_prefix <prefix_path>``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Expands some common path variables for the given <prefix_path> prefix. This is useful if you installed something in the <prefix_path> using $(./configure --prefix=<prefix_path> && make install) and want to use it in the project.

Variables set::

    CPATH
    LD_LIBRARY_PATH
    LIBRARY_PATH
    MANPATH
    PATH
    PKG_CONFIG_PATH

Example::

    ./configure --prefix=$HOME/rubies/ruby-1.9.3
    make && make install
    # Then in the .envrc
    load_prefix ~/rubies/ruby-1.9.3


.. _stdlib_layout:
``layout <type>``
^^^^^^^^^^^^^^^^^

A semantic command dispatch used to describe common project layouts. For example
if ruby projects have a GEM_HOME set under the project root then define a
use_ruby() function that does just that.

Some default layouts are provided with the stdlib when they seem to be
applicable everywhere. If this doesn't work for you it's always possible to
override them by creating the same function inside the ``direnvrc``.


.. _stdlib_layout_ruby:
``layout ruby``
^^^^^^^^^^^^^^^

Sets the GEM_HOME environment variable to "$PWD/.direnv/ruby/RUBY_VERSION".This forces the installation of any gems into the project's sub-folder. If you're using bundler it will create wrapper programs that can be invoked directly instead of using the $(bundle exec) prefix.


.. _stdlib_layout_python:
``layout python``
^^^^^^^^^^^^^^^^^

Creates and loads a virtualenv environment under "$PWD/.direnv/virtualenv". This forces the installation of any egg into the project's sub-folder.


.. _stdlib_layout_node:
``layout node``
^^^^^^^^^^^^^^^

Adds "$PWD/node_modules/.bin" to the PATH environment variable.


.. _stdlib_layout_go:
``layout go``
^^^^^^^^^^^^^

Sets the GOPATH environment variable to the current directory and adds $PWD/bin to the PATH.


.. _stdlib_use:
``use <program_name> [<version>]``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A semantic command dispatch intended for loading external dependencies into the
environment. It's used to express the dependency on something like a program.

The stdlib doesn't define default use dispatch functions because they are
dependent on your operating system and setup (well, except rbenv).

Example::

    use_ruby() {
      echo "Ruby $1"
    }
    use ruby 1.9.3
    # output: Ruby 1.9.3


.. _stdlib_rbenv:
``use rbenv``
^^^^^^^^^^^^^

Loads rbenv which in turn makes the ruby wrappers available on the PATH.


.. _stdlib_rvm:
``rvm [...]``
^^^^^^^^^^^^^

Used to activate `RVM <http://rvm.io>`_ in the context of the envrc. Activation
is done on first usage and the command should work just like in the shell.

Because RVM changes a lot this function might not work as expected. Please
submit a bug report if you're encountering issues with it's usage.

This function works best if RVM is not activated in the main shell.

