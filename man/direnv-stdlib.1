.TH DIRENV\-STDLIB 1 "APRIL 2014" direnv "User Manuals"
.SH NAME
.PP
direnv_stdlib \- the ".envrc" stdlib
.SH SYNOPSIS
.PP
\fB\fCdirenv stdlib\fR
.SH DESCRIPTION
.PP
Outputs a bash script called the \fIstdlib\fP\&. The following commands are included in that script and loaded in the context of an ".envrc". Additionnaly to that, it also loads the file in "~/.direnvrc" if it exists.
.SH STDLIB
.RS
.IP \(bu 2
\fB\fChas\fR \fIcommand\fP:
Returns 0 if the \fIcommand\fP is available. Returns 1 otherwise. It can be a binary in the PATH or a shell function.
.RE
.PP
Example:
.PP
.RS
.nf
if has curl; then
  echo "Yes we do"
fi
.fi
.RE
.RS
.IP \(bu 2
\fB\fCexpand_path\fR \fIrel_path\fP [\fIrelative_to\fP]:
Outputs the absolute path of \fIrel_path\fP relative to \fIrelative_to\fP or the current directory.
.RE
.PP
Example:
.PP
.RS
.nf
cd /usr/local/games
expand_path ../foo
# output: /usr/local/foo
.fi
.RE
.RS
.IP \(bu 2
\fB\fCdotenv\fR [\fIdotenv_path\fP]:
Loads a ".env" file into the current environment
.IP \(bu 2
\fB\fCuser_rel_path\fR \fIabs_path\fP:
Transforms an absolute path \fIabs_path\fP into a user\-relative path if possible.
.RE
.PP
Example:
.PP
.RS
.nf
echo $HOME
# output: /home/user
user_rel_path /home/user/my/project
# output: ~/my/project
user_rel_path /usr/local/lib
# output: /usr/local/lib
.fi
.RE
.RS
.IP \(bu 2
\fB\fCfind_up\fR \fIfilename\fP:
Outputs the path of \fIfilename\fP when searched from the current directory up to /. Returns 1 if the file has not been found.
.RE
.PP
Example:
.PP
.RS
.nf
cd /usr/local/my
mkdir \-p project/foo
touch bar
cd project/foo
find_up bar
# output: /usr/local/my/bar
.fi
.RE
.RS
.IP \(bu 2
\fB\fCsource_env\fR \fIfile\fIor\fPdir_path\fP:
Loads another ".envrc" either by specifying its path or filename.
.IP \(bu 2
\fB\fCsource_up\fR [\fIfilename\fP]:
Loads another ".envrc" if found with the \fB\fCfind_up\fR command.
.IP \(bu 2
\fB\fCdirenv_load\fR [\fIcommand\-generating\-dump\-output\fP]
Applies the environment generated by running \fIargv\fP as a
command. This is useful for adopting the environment of a child
process \- cause that process to run "direnv dump" and then wrap
the results with direnv_load.
.RE
.PP
Example:
.PP
.RS
.nf
direnv_load opam\-env exec \-\- direnv dump
.fi
.RE
.RS
.IP \(bu 2
\fB\fCPATH_add\fR \fIpath\fP:
Prepends the expanded \fIpath\fP to the PATH environment variable. It prevents a common mistake where PATH is replaced by only the new \fIpath\fP\&.
.RE
.PP
Example:
.PP
.RS
.nf
pwd
# output: /home/user/my/project
PATH_add bin
echo $PATH
# output: /home/user/my/project/bin:/usr/bin:/bin
.fi
.RE
.RS
.IP \(bu 2
\fB\fCpath_add\fR \fIvarname\fP \fIpath\fP:
Works like \fB\fCPATH_add\fR except that it's for an arbitrary \fIvarname\fP\&.
.IP \(bu 2
\fB\fCload_prefix\fR \fIprefix_path\fP:
Expands some common path variables for the given \fIprefix_path\fP prefix. This is useful if you installed something in the \fIprefix_path\fP using
\fB\fC\&./configure \-\-prefix=$prefix_path && make install\fR and want to use it in
the project.
.RE
.PP
Variables set:
.PP
.RS
.nf
CPATH
LD_LIBRARY_PATH
LIBRARY_PATH
MANPATH
PATH
PKG_CONFIG_PATH
.fi
.RE
.PP
Example:
.PP
.RS
.nf
\&./configure \-\-prefix=$HOME/rubies/ruby\-1.9.3
make && make install
# Then in the .envrc
load_prefix ~/rubies/ruby\-1.9.3
.fi
.RE
.RS
.IP \(bu 2
\fB\fClayout\fR \fItype\fP:
A semantic dispatch used to describe common project layouts.
.IP \(bu 2
\fB\fClayout go\fR:
Sets the GOPATH environment variable to the current directory.
.IP \(bu 2
\fB\fClayout node\fR:
Adds "$PWD/node_modules/.bin" to the PATH environment variable.
.IP \(bu 2
\fB\fClayout perl\fR:
Setup environment variables required by perl's local::lib
See 
\[la]http://search.cpan.org/dist/local-lib/lib/local/lib.pm\[ra] for more
details
.IP \(bu 2
\fB\fClayout python\fR [\fIpython_exe\fP]:
Creates and loads a virtualenv environment under \fB\fC$PWD/.direnv/python\-$python_version\fR\&. This forces the installation of any egg into the project's sub\-folder.
.PP
It's possible to specify the python executable if you want to use different versions of python (eg: \fB\fClayout python python3\fR).
.PP
Note that previously virtualenv was located under \fB\fC$PWD/.direnv/virtualenv\fR and will be re\-used by direnv if it exists.
.IP \(bu 2
\fB\fClayout python3\fR:
A shortcut for \fB\fClayout python python3\fR
.IP \(bu 2
\fB\fClayout ruby\fR:
Sets the GEM\fIHOME environment variable to `$PWD/.direnv/ruby/RUBY\fPVERSION\fB\fC\&. This forces the installation of any gems into the project's sub\-folder.
If you're using bundler it will create wrapper programs that can be invoked directly instead of using the\fRbundle exec` prefix.
.IP \(bu 2
\fB\fCuse\fR \fIprogram_name\fP [\fIversion\fP]:
A semantic command dispatch intended for loading external dependencies into the environment.
.RE
.PP
Example:
.PP
.RS
.nf
use_ruby() {
  echo "Ruby $1"
}
use ruby 1.9.3
# output: Ruby 1.9.3
.fi
.RE
.RS
.IP \(bu 2
\fB\fCuse rbenv\fR:
Loads rbenv which add the ruby wrappers available on the PATH.
.IP \(bu 2
\fB\fCrvm\fR ...:
Should work just like in the shell if you have rvm installed.
.RE
.SH COPYRIGHT
.PP
Copyright (C) 2014 zimbatm 
\[la]http://zimbatm.com\[ra] and contributors under the MIT licence.
.SH SEE ALSO
.PP
.BR direnv (1)
